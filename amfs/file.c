/*
 * Copyright (c) 2015 Mohit Goyal
 * Copyright (c) 2015-2106 Stony Brook University
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "amfs.h"

/**
 * writing len bytes from buf into pattern file
 **/
int amfs_write_pattern_file(struct file *pattern_filp, void *buf, int len)
{
	int err = 0, bytes = 0;
	mm_segment_t oldfs;

	/* check for validity of file */
	if (!pattern_filp || IS_ERR(pattern_filp)) {
		printk("Error: Pattern file does not exist\n");
		err = (int) PTR_ERR(pattern_filp);
		goto out;
	}

	/* check for write permission of file */
	if (!pattern_filp->f_op->write) {
		printk("Error: Write not allowed by file system\n");
		err = -EACCES;
		goto out;
	}

	/* check for write permission of file */
	if (!(pattern_filp->f_mode & FMODE_WRITE)) {
		printk("Error: Pattern file inaccessible to write\n");
		err = -EIO;
		goto out;
	}

	oldfs = get_fs();
	set_fs(KERNEL_DS);
	bytes = vfs_write(pattern_filp, buf, len, &pattern_filp->f_pos);
	set_fs(oldfs);

	return bytes;

out:
	return err;
}

/**
 * reading len bytes from file into buf
 **/
int amfs_read_file(struct file *filp, void *buf, int len, int offset)
{
	int err = 0, bytes = 0;
	mm_segment_t oldfs;

	/* check for validity of file */
	if (!filp || IS_ERR(filp)) {
		printk("Error: File does not exist\n");
		err = (int) PTR_ERR(filp);
		goto out;
	}

	/* check for read permission of file */
	if (!filp->f_op->read) {
		printk("Error: Read not allowed by file system\n");
		err = -EACCES;
		goto out;
	}

	/* check for read permission of file */
	if (!(filp->f_mode & FMODE_READ)) {
		printk("Error: File inaccessible to read\n");
		err = -EIO;
		goto out;
	}

	oldfs = get_fs();
	set_fs(KERNEL_DS);
	bytes = vfs_read(filp, buf, len, &filp->f_pos);
	set_fs(oldfs);

	return bytes;

out:
	return err;
}

#ifdef EXTRA_CREDIT
/**
 * scan the whole file on open and close for virus pattern
 * checks for virus across buffers as it can be possible that
 * some part of virus pattern is one buffer and some part in
 * other buffer
 **/
int amfs_file_check(struct file *file)
{
	int err = 0, rc_name = 0, rc_ver = 0;
	int ver_no = 0, pos = 0, read_ret = 0;
	int file_size = 0, read_offset = 0, bytes_to_read = 0;
	char *buf = NULL, *tmp_buf = NULL, *temp_buf = NULL;
	struct file *lower_file;
	struct super_block *amfs_sb;
	struct list_head *head, *iter;
	struct pattern_node *tmp;

	amfs_sb = file->f_path.dentry->d_inode->i_sb;
	head = AMFS_SB(amfs_sb)->list;
	ver_no = AMFS_SB(amfs_sb)->ver_no;

	/* get the lower file */
	lower_file = amfs_lower_file(file);

	/* check for validity of file */
	if (!lower_file || IS_ERR(lower_file)) {
		printk("Error: File does not exist\n");
		err = (int) PTR_ERR(lower_file);
		goto out;
	}

	/* check for read permission of file */
	if (!lower_file->f_op->read) {
		printk("Error: Read not allowed by file system\n");
		err = -EACCES;
		goto out;
	}

	file_size = i_size_read(lower_file->f_path.dentry->d_inode);
	bytes_to_read = file_size;

	#ifdef DEBUG
	printk("amfs_file_check bytes_to_read: %d\n", bytes_to_read);
	#endif

	/* memory allocation for the buffers */
	tmp_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
	if (!tmp_buf) {
		err = -ENOMEM;
		goto out;
	}

	temp_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);
	if (!tmp_buf) {
		err = -ENOMEM;
		goto out;
	}

	buf = kzalloc(2*PAGE_SIZE, GFP_KERNEL);
	if (!buf) {
		err = -ENOMEM;
		goto out;
	}

	lower_file->f_pos = 0;
	while (bytes_to_read > 0) {
		read_ret = amfs_read_file(lower_file, tmp_buf,
										PAGE_SIZE, read_offset);
		if (read_ret < 0) {
			printk("Error: Fail to read file\n");
			err = read_ret;
			goto out;
		} else if (read_ret == PAGE_SIZE) {
			memcpy(buf + pos, temp_buf, read_ret);
			bytes_to_read -= read_ret;
			read_offset += 1;
			pos = read_ret;
		} else {
			memcpy(buf + pos, temp_buf, read_ret);
			bytes_to_read -= read_ret;
			read_offset += 1;
			pos = read_ret;
		}

		if (bytes_to_read > 0) {
			read_ret = amfs_read_file(lower_file, temp_buf,
										PAGE_SIZE, read_offset);
			if (read_ret < 0) {
				printk("Error: Fail to read file.\n");
				err = read_ret;
				goto out;
			} else if (read_ret == PAGE_SIZE) {
				memcpy(buf + pos, temp_buf, read_ret);
				bytes_to_read -= read_ret;
				read_offset += 1;
			} else {
				memcpy(buf + pos, temp_buf, read_ret);
				bytes_to_read -= read_ret;
				read_offset += 1;
			}
		}

		/* scan buf with virus pattern list for possible virus */
		list_for_each(iter, head) {
			tmp = list_entry(iter, struct pattern_node, list);
			if (strstr(buf, tmp->pattern) != NULL) {
				printk("Virus pattern found while amfs open check\n");

				/* set the ver attribute of file */
				/* rc_ver = file->f_path.dentry->d_inode->i_op->setxattr(
									file->f_path.dentry, AMFS_XATTR_VER,
											&ver_no, sizeof(ver_no), 0); */
				rc_ver = vfs_setxattr(file->f_path.dentry, AMFS_XATTR_VER, &ver_no, sizeof(ver_no), 0);
				printk("amfs_file_check: rc_name: %d\n", rc_ver);
				if (rc_ver > 0) {
					printk("Error: Fail to set ver attribute\n");
					err = rc_ver;
					goto out;
				}

				/* set the attribute of file as bad */
				/* rc_name = file->f_path.dentry->d_inode->i_op->setxattr(
									file->f_path.dentry, AMFS_XATTR_NAME,
											AMFS_XATTR_BAD, AMFS_XATTR_SIZE, 0); */
				rc_name = vfs_setxattr(file->f_path.dentry, AMFS_XATTR_NAME, AMFS_XATTR_BAD, AMFS_XATTR_SIZE, 0);
				printk("amfs_file_check: rc_name: %d\n", rc_name);
				if (rc_name > 0) {
					printk("Error: Fail to set name attribute\n");
					err = rc_name;
					goto out;
				}
				err = -EPERM;
				goto out;
			}
		}
		if (bytes_to_read > 0) {
			memset(buf, 0, 2*PAGE_SIZE);
			pos = 0;
			memcpy(buf + pos, temp_buf, read_ret);
			pos = read_ret;
		}
	}

	/* set the ver attribute of file */
	/* rc_ver = file->f_path.dentry->d_inode->i_op->setxattr(
						file->f_path.dentry, AMFS_XATTR_VER,
								&ver_no, sizeof(ver_no), 0); */
	rc_ver = vfs_setxattr(file->f_path.dentry, AMFS_XATTR_VER, &ver_no, sizeof(ver_no), 0);
	printk("amfs_file_check: rc_name:: %d\n", rc_ver);
	if (rc_ver > 0) {
		printk("Error: Fail to set ver attribute\n");
		err = rc_ver;
		goto out;
	}

	/* set the attribute of file as good */
	/* rc_name = file->f_path.dentry->d_inode->i_op->setxattr(
						file->f_path.dentry, AMFS_XATTR_NAME,
								AMFS_XATTR_GOOD, AMFS_XATTR_SIZE, 0); */
	rc_name = vfs_setxattr(file->f_path.dentry, AMFS_XATTR_NAME, AMFS_XATTR_GOOD, AMFS_XATTR_SIZE, 0);
	printk("amfs_file_check: rc_name:: %d\n", rc_name);
	if (rc_name > 0) {
		printk("Error: Fail to set name attribute\n");
		err = rc_name;
		goto out;
	}

out:
	/* memory deallocation of temporary buffers */
	if (tmp_buf != NULL)
		kfree(tmp_buf);
	if (temp_buf != NULL)
		kfree(temp_buf);
	if (buf != NULL)
		kfree(buf);
	return err;
}

/**
 * file scanning for virus on open and close
 **/
int amfs_file_scan(struct inode *inode, struct file *file)
{
	int err = 0;
	int rc_name = 0, rc_ver = 0;
	int ver_no = 0, amfs_xattr_ver;
	char *amfs_xattr_val = "";
	struct super_block *amfs_sb;

	if (S_ISREG(inode->i_mode)) {
		amfs_sb = file->f_path.dentry->d_inode->i_sb;
		ver_no = AMFS_SB(amfs_sb)->ver_no;

		rc_name = file->f_path.dentry->d_inode->i_op->getxattr(
				file->f_path.dentry, AMFS_XATTR_NAME,
					amfs_xattr_val, AMFS_XATTR_SIZE);

		rc_ver = file->f_path.dentry->d_inode->i_op->getxattr(
				file->f_path.dentry, AMFS_XATTR_VER,
						&amfs_xattr_ver, sizeof(amfs_xattr_ver));

		#ifdef DEBUG
		printk("amfs_file_scan amfs_xattr_val: %s\n", amfs_xattr_val);
		printk("amfs_file_scan amfs_xattr_ver: %d\n", amfs_xattr_ver);
		#endif

		if ((strncmp(amfs_xattr_val, AMFS_XATTR_GOOD,
						 AMFS_XATTR_SIZE) == 0)
					&& (amfs_xattr_ver == ver_no)) {
			printk("File does not contain any virus\n");
		} else if ((strncmp(amfs_xattr_val, AMFS_XATTR_BAD,
						AMFS_XATTR_SIZE) == 0)
					&& (amfs_xattr_ver == ver_no)) {
			printk("Virus pattern found while amfs file scan\n");
			err = -EPERM;
			goto out_err;
		} else if (((strncmp(amfs_xattr_val, AMFS_XATTR_GOOD,
						AMFS_XATTR_SIZE) != 0) && (strncmp(amfs_xattr_val,
						AMFS_XATTR_BAD, AMFS_XATTR_SIZE) != 0)) ||
						((strncmp(amfs_xattr_val, AMFS_XATTR_GOOD,
						AMFS_XATTR_SIZE) == 0) && (amfs_xattr_ver != ver_no))
						|| ((strncmp(amfs_xattr_val, AMFS_XATTR_BAD,
						AMFS_XATTR_SIZE) == 0) && (amfs_xattr_ver != ver_no))) {
			err = amfs_file_check(file);
			if (err < 0) {
				printk("Virus pattern found while amfs file scan.\n");
				goto out_err;
			}
		}
	}

out_err:
	return err;
}
#endif

/**
 * read function scans buf for possible virus
 * while reading data from file
 **/
static ssize_t amfs_read(struct file *file, char __user *buf,
			    size_t count, loff_t *ppos)
{
	int err;
	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;

	int errno = 0, rc_name = 0, rc_ver = 0;
	int ver_no = 0, amfs_xattr_ver;
	char *amfs_xattr_val = "";
	char *tmp_buf = NULL;
	struct super_block *amfs_sb;
	struct list_head *head, *iter;
	struct pattern_node *tmp;

	lower_file = amfs_lower_file(file);
	err = vfs_read(lower_file, buf, count, ppos);

	if (err >= 0) {
		amfs_sb = file->f_path.dentry->d_inode->i_sb;
		head = AMFS_SB(amfs_sb)->list;
		ver_no = AMFS_SB(amfs_sb)->ver_no;

		rc_name = file->f_path.dentry->d_inode->i_op->getxattr(
							dentry, AMFS_XATTR_NAME, amfs_xattr_val,
								AMFS_XATTR_SIZE);
		rc_ver = file->f_path.dentry->d_inode->i_op->getxattr(
							dentry, AMFS_XATTR_VER, &amfs_xattr_ver,
								sizeof(amfs_xattr_ver));

		#ifdef DEBUG
		printk("amfs_read ver_no: %d\n", ver_no);
		printk("amfs_read amfs_xattr_val: %s\n", amfs_xattr_val);
		printk("amfs_read amfs_xattr_ver: %d\n", amfs_xattr_ver);
		#endif

		/* checking attributes of files if marked bad and version matched */
		if ((strncmp(amfs_xattr_val, AMFS_XATTR_BAD, AMFS_XATTR_SIZE) == 0)
						&& (amfs_xattr_ver == ver_no)) {
			printk("Virus pattern found while amfs read\n");
			errno = -EPERM;
			goto out;
		}

		/* memory allocation for temp buf */
		tmp_buf = kmalloc(count, GFP_KERNEL);
		if (!tmp_buf) {
			printk("Error: Fail to allocate memory to the tmp buf\n");
			errno = -ENOMEM;
			goto out;
		}

		/* copying user buf into kernel space */
		errno = copy_from_user(tmp_buf, buf, count);

		/* check for successful copying of user arguments into kernel */
		if (errno) {
			printk("Error: Fail to copy user buf into kernel space\n");
			errno = -EFAULT;
			goto out;
		}

		/* scan buf with virus pattern list for possible virus */
		list_for_each(iter, head) {
			tmp = list_entry(iter, struct pattern_node, list);
			if (strstr(tmp_buf, tmp->pattern) != NULL) {
				printk("Virus pattern found while reading file\n");

				/* set the ver attribute of file as the pattern version */
				/* rc_ver = file->f_path.dentry->d_inode->i_op->setxattr(
								dentry, AMFS_XATTR_VER,
									&ver_no, sizeof(ver_no), 0); */
				rc_ver = vfs_setxattr(dentry, AMFS_XATTR_VER, &ver_no, sizeof(ver_no), 0);
				printk("amfs_read: rc_name: %d", rc_ver);
				if (rc_ver > 0) {
					printk("Error: Fail to set ver attribute of \
								file while amfs read\n");
					errno = rc_ver;
					goto out;
				}

				/* set the attribute of file as bad */
				/* rc_name = file->f_path.dentry->d_inode->i_op->setxattr(
								dentry, AMFS_XATTR_NAME, AMFS_XATTR_BAD,
									AMFS_XATTR_SIZE, 0); */
				rc_name = vfs_setxattr(dentry, AMFS_XATTR_NAME, AMFS_XATTR_BAD, AMFS_XATTR_SIZE, 0);
				printk("amfs_read: rc_name: %d", rc_name);
				if (rc_name > 0) {
					printk("Error: Fail to set name attribute\n");
					errno = rc_name;
					goto out;
				}
				errno = -EPERM;
				goto out;
			}
		}
		/* update our inode atime upon a successful lower read */
		fsstack_copy_attr_atime(dentry->d_inode,
						file_inode(lower_file));
	}
	return err;

out:
	/* memory deallocation of tmp buf */
	if (tmp_buf != NULL)
		kfree(tmp_buf);
	return errno;
}

/**
 * write function scans buf for possible virus
 * while writing buf into file
 **/
static ssize_t amfs_write(struct file *file, const char __user *buf,
				size_t count, loff_t *ppos)
{
	int err;
	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;

	int errno = 0, rc_name = 0, rc_ver = 0;
	int amfs_xattr_ver, ver_no;
	char *amfs_xattr_val = "";
	char *tmp_buf = NULL;
	struct list_head *head, *iter;
	struct pattern_node *tmp;
	struct super_block *amfs_sb;

	amfs_sb = file->f_path.dentry->d_inode->i_sb;
	head = AMFS_SB(amfs_sb)->list;
	ver_no = AMFS_SB(amfs_sb)->ver_no;

	tmp_buf = (char *)kzalloc(count, GFP_KERNEL);
	err = copy_from_user(tmp_buf, buf, count);

	rc_name = file->f_path.dentry->d_inode->i_op->getxattr(dentry,
					AMFS_XATTR_NAME, amfs_xattr_val, AMFS_XATTR_SIZE);
	rc_ver = file->f_path.dentry->d_inode->i_op->getxattr(dentry,
					AMFS_XATTR_VER, &amfs_xattr_ver, sizeof(amfs_xattr_ver));

	#ifdef DEBUG
	printk("amfs_write amfs_xattr_val: %s\n", amfs_xattr_val);
	printk("amfs_write amfs_xattr_ver: %d\n", amfs_xattr_ver);
	#endif

	/* checking attributes of files if marked bad and version matched */
	if ((strncmp(amfs_xattr_val, AMFS_XATTR_BAD, AMFS_XATTR_SIZE) == 0)
				&& (amfs_xattr_ver == ver_no)) {
		printk("Virus pattern found while amfs write\n");
		errno = -EPERM;
		goto out;
	}

	/* scan buf with virus pattern list for possible virus */
	list_for_each(iter, head) {
		tmp = list_entry(iter, struct pattern_node, list);
		if (strstr(tmp_buf, tmp->pattern) != NULL) {
			printk("Virus pattern found while writing file\n");
			errno = -EPERM;
			goto out;
		}
	}
	lower_file = amfs_lower_file(file);
	err = vfs_write(lower_file, buf, count, ppos);
	/* update our inode times+sizes upon a successful lower write */
	if (err >= 0) {
		fsstack_copy_inode_size(dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(dentry->d_inode,
					file_inode(lower_file));
	}

	return err;

out:
	/* memory deallocation of tmp buf */
	if (tmp_buf != NULL)
		kfree(tmp_buf);
	return errno;
}

struct amfs_getdents_callback {
	struct dir_context ctx;
	struct dir_context *caller;
	struct dentry *curr_dentry;
	struct super_block *sb;
};

static int amfs_filldir(struct dir_context *ctx, const char *lower_name,
		 int lower_namelen, loff_t offset, u64 ino, unsigned int d_type)
{
	int rc, rc_name = 0, rc_ver = 0;
	int amfs_xattr_ver = 0, ver_no = 0;
	int bad_file_found = 0;
	char *amfs_xattr_val = "";
	struct super_block *amfs_sb;
	struct dentry *curr_dentry, *lower_dentry;
	struct qstr this;
	struct amfs_getdents_callback *buf =
				container_of(ctx, struct amfs_getdents_callback, ctx);

	/* find the dentry for the lower file */
	curr_dentry = buf->curr_dentry;
	this.name = lower_name;
	this.len = lower_namelen;
	this.hash = full_name_hash(this.name, this.len);
	lower_dentry = d_lookup(curr_dentry, &this);

	amfs_sb = buf->sb;
	ver_no = AMFS_SB(amfs_sb)->ver_no;
	
	if (lower_dentry != NULL) {
		/* get attribute for the bad marked files and skipping */
		rc_name = lower_dentry->d_inode->i_op->getxattr(lower_dentry,
						AMFS_XATTR_NAME, amfs_xattr_val, AMFS_XATTR_SIZE);
		rc_ver = lower_dentry->d_inode->i_op->getxattr(lower_dentry,
						AMFS_XATTR_VER, &amfs_xattr_ver, sizeof(amfs_xattr_ver));

		#ifdef DEBUG
		printk("amfs_filldir lower_name: %s\n", lower_name);
		printk("amfs_filldir amfs_xattr_val: %s\n", amfs_xattr_val);
		printk("amfs_filldir amfs_xattr_ver: %d\n", amfs_xattr_ver);
		#endif

		/* checking attributes of files if marked bad and ver matched */
		if ((strncmp(amfs_xattr_val, AMFS_XATTR_BAD, AMFS_XATTR_SIZE) == 0) &&
						(amfs_xattr_ver == ver_no)) {
			printk("Virus pattern found while amfs filldir\n");
			rc = -ENOENT;
			bad_file_found = 1;
		}
	}
	buf->caller->pos = buf->ctx.pos;
	if (!bad_file_found)
		rc = !dir_emit(buf->caller, lower_name, lower_namelen, ino, d_type);

	return rc;
}

static int amfs_readdir(struct file *file, struct dir_context *ctx)
{
	int err;
	struct file *lower_file = NULL;
	struct dentry *dentry = file->f_path.dentry;

	struct amfs_getdents_callback buf = {
		.ctx.actor = amfs_filldir,
		.caller = ctx,
		.sb = dentry->d_inode->i_sb,
	};

	lower_file = amfs_lower_file(file);
	buf.curr_dentry = lower_file->f_path.dentry;
	lower_file->f_pos = ctx->pos;
	err = iterate_dir(lower_file, &buf.ctx);
	ctx->pos = buf.ctx.pos;

	if (err < 0)
		goto out;
	if (err >= 0) {
		d_invalidate(lower_file->f_path.dentry);
		fsstack_copy_attr_atime(dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}

static long amfs_unlocked_ioctl(struct file *file, unsigned int cmd,
				  unsigned long arg)
{
	long err = -ENOTTY;
	struct file *lower_file;

	int ver_no = 0, pattern_found = 0;
	int write_ret = 0, pattern_size = 0;
	char *karg = NULL, *pattern_file = NULL, *pattern = NULL;
	unsigned char *buf = NULL;
	struct file *pattern_filp = NULL;
	struct super_block *sb;
	struct list_head *iter, *q, *head;
	struct pattern_node *tmp = NULL, *temp = NULL;

	/* taking link list and pattern file info from fs superblock */
	sb = file->f_path.dentry->d_inode->i_sb;
	head = AMFS_SB(sb)->list;
	pattern_file = AMFS_SB(sb)->pattern_file;
	ver_no = AMFS_SB(sb)->ver_no;

	switch (cmd) {
	/* displaying virus pattern */
	case R_IOCTL:
		karg = (char *)arg;
		/* copying list from kernel space to user and
		 * check for successful copying of list into kernel
		 */
		list_for_each(iter, head) {
			tmp = list_entry(iter, struct pattern_node, list);
			err = copy_to_user(karg, tmp->pattern, strlen(tmp->pattern));
			if (err != 0) {
				printk("Error: Fail to copy pattern data into user land\n");
				goto out;
			}
			karg = karg + strlen(tmp->pattern);
				err = copy_to_user(karg, "\n", strlen("\n"));
			if (err != 0) {
				printk("Error: Fail to copy pattern data into user land\n");
				goto out;
			}
			karg = karg + 1;
		}
		/* removing the extra new line at the end */
		karg = karg - 1;
		*karg = 0;
		return err;

	/* adding new pattern to pattern list */
	case W_IOCTL:
		pattern = (char *)arg;
		pattern_size = strnlen_user(pattern, 256);
		/* check for zero length and max length of pattern */
		if (pattern_size == 0 || pattern_size > 256) {
			printk("Error: Pattern length not appropriate\n");
			err = 1;
			goto out;
		}

		/* memory allocation for buf */
		buf = (char *)kzalloc(pattern_size, GFP_KERNEL);
		if (!buf) {
			printk("Error: Fail to allocate memory for the buffer\n");
			err = -ENOMEM;
			goto out;
		}

		/* copying user buf into kernel space */
		err = copy_from_user(buf, (char *) arg, pattern_size - 1);
		if (err != 0) {
			printk("Error: Fail to copy user arg into kernel space\n");
			goto out;
		}

		/* check if the pattern already exists */
		list_for_each_entry(tmp, head, list) {
			if (strcmp(tmp->pattern, buf) == 0) {
				printk("Error: Pattern already exist in pattern.db\n");
				err = 2;
				goto out;
			}
		}

		/* memory allocation for linklist node */
		temp = (struct pattern_node *)kzalloc(sizeof(struct pattern_node),
						GFP_KERNEL);
		if (!temp) {
			printk("Error: Fail to allocate memory for the buffer\n");
			err = -ENOMEM;
			goto out;
		}
		temp->pattern = buf;
		list_add_tail(&(temp->list), head);

		#ifdef DEBUGLIST
		printk("user data: %s\n", (char *)arg);
		printk("Adding new pattern\n");
		list_for_each(iter, head) {
			tmp = list_entry(iter, struct pattern_node, list);
			printk("_:%s:_\n", tmp->pattern);
		}
		#endif

		pattern_filp = filp_open(pattern_file, O_WRONLY | O_APPEND, 0);
		/* check for validity of file */
		if (!pattern_filp || IS_ERR(pattern_filp)) {
			printk("Error: Pattern file does not exist\n");
			err = (int) PTR_ERR(pattern_filp);
			goto out;
		}

		/* adding pattern to pattern file */
		write_ret = amfs_write_pattern_file(pattern_filp, buf, pattern_size-1);
		if (write_ret < 0) {
			printk("Error: Fail to add pattern to pattern.db file\n");
			err = -EIO;
			goto out;
		}

		write_ret = amfs_write_pattern_file(pattern_filp, "\n", strlen("\n"));
		if (write_ret < 0) {
			printk("Error: Fail to add pattern to pattern.db file\n");
			err = -EIO;
			goto out;
		}
		/* updating version of the file system */
		ver_no += 1;
		AMFS_SB(sb)->ver_no = ver_no;
		return err;

	/* removing pattern from pattern list */
	case WR_IOCTL:
		pattern = (char *)arg;
		pattern_size = strnlen_user(pattern, 256);
			/* check for zero length and max length of pattern */
		if (pattern_size == 0 || pattern_size > 256) {
			printk("Error: User has given zero length pattern\n");
			err = 1;
			goto out;
		}

		/* memory allocation for buf */
		buf = (char *)kzalloc(pattern_size, GFP_KERNEL);
		if (!buf) {
			printk("Error: Fail to allocate memory for the buffer\n");
			err = -ENOMEM;
			goto out;
		}

		/* copying user buf into kernel space */
		err = copy_from_user(buf, (char *) arg, pattern_size - 1);
		if (err != 0) {
			printk("Error: Fail to copy user arg into kernel space\n");
			goto out;
		}

		#ifdef DEBUG
		printk("user data: %s\n", (char *)arg);
		printk("Removing new pattern\n");
		list_for_each(iter, head) {
			tmp = list_entry(iter, struct pattern_node, list);
			printk("_:%s:_\n", tmp->pattern);
		}
		#endif

		/* checking if the pattern does not exist */
		list_for_each_safe(iter, q, head) {
			tmp = list_entry(iter, struct pattern_node, list);
			if (strcmp(tmp->pattern, buf) == 0) {
				list_del(iter);
				kfree(tmp->pattern);
				kfree(tmp);
				pattern_found = 1;
			}
		}

		if (!pattern_found) {
			printk("Error: Pattern to be removed does not \
							exist in the pattern.db\n");
			err = 2;
			goto out;
		}

		pattern_filp = filp_open(pattern_file, O_TRUNC | O_WRONLY, 0);
		/* check for validity of file */
		if (!pattern_filp || IS_ERR(pattern_filp)) {
			printk("Error: Pattern file does not exist\n");
			err = (int) PTR_ERR(pattern_filp);
			goto out;
		}

		/* updating the pattern file after removing pattern */
		list_for_each(iter, head) {
			tmp = list_entry(iter, struct pattern_node, list);
				write_ret = amfs_write_pattern_file(pattern_filp,
							(void *)tmp->pattern, strlen(tmp->pattern));
			if (write_ret < 0) {
				printk("Error: Fail to add pattern to pattern.db\n");
				err = -EIO;
				goto out;
			}

			write_ret = amfs_write_pattern_file(pattern_filp,
							(void *)"\n", strlen("\n"));
			if (write_ret < 0) {
				printk("Error: Fail to add new line to pattern.db file\n");
				err = -EIO;
				goto out;
			}
		}

		/* updating version of the file system */
		ver_no += 1;
		AMFS_SB(sb)->ver_no = ver_no;
		return err;

	default:
		return err;
	}

	lower_file = amfs_lower_file(file);

	/* XXX: use vfs_ioctl if/when VFS exports it */
	if (!lower_file || !lower_file->f_op)
		goto out;
	if (lower_file->f_op->unlocked_ioctl)
		err = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);

	/* some ioctls can change inode attributes (EXT2_IOC_SETFLAGS) */
	if (!err)
		fsstack_copy_attr_all(file_inode(file),
				      file_inode(lower_file));
out:
	if (buf != NULL)
		kfree(buf);
	return err;
}

#ifdef CONFIG_COMPAT
static long amfs_compat_ioctl(struct file *file, unsigned int cmd,
				unsigned long arg)
{
	long err = -ENOTTY;
	struct file *lower_file;

	lower_file = amfs_lower_file(file);

	/* XXX: use vfs_ioctl if/when VFS exports it */
	if (!lower_file || !lower_file->f_op)
		goto out;
	if (lower_file->f_op->compat_ioctl)
		err = lower_file->f_op->compat_ioctl(lower_file, cmd, arg);

out:
	return err;
}
#endif

static int amfs_mmap(struct file *file, struct vm_area_struct *vma)
{
	int err = 0;
	bool willwrite;
	struct file *lower_file;
	const struct vm_operations_struct *saved_vm_ops = NULL;

	/* this might be deferred to mmap's writepage */
	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);

	/*
	 * File systems which do not implement ->writepage may use
	 * generic_file_readonly_mmap as their ->mmap op.  If you call
	 * generic_file_readonly_mmap with VM_WRITE, you'd get an -EINVAL.
	 * But we cannot call the lower ->mmap op, so we can't tell that
	 * writeable mappings won't work.  Therefore, our only choice is to
	 * check if the lower file system supports the ->writepage, and if
	 * not, return EINVAL (the same error that
	 * generic_file_readonly_mmap returns in that case).
	 */
	lower_file = amfs_lower_file(file);
	if (willwrite && !lower_file->f_mapping->a_ops->writepage) {
		err = -EINVAL;
		printk(KERN_ERR "amfs: lower file system does not "
		       "support writeable mmap\n");
		goto out;
	}

	/*
	 * find and save lower vm_ops.
	 *
	 * XXX: the VFS should have a cleaner way of finding the lower vm_ops
	 */
	if (!AMFS_F(file)->lower_vm_ops) {
		err = lower_file->f_op->mmap(lower_file, vma);
		if (err) {
			printk(KERN_ERR "amfs: lower mmap failed %d\n", err);
			goto out;
		}
		saved_vm_ops = vma->vm_ops; /* save: came from lower ->mmap */
	}

	/*
	 * Next 3 lines are all I need from generic_file_mmap.  I definitely
	 * don't want its test for ->readpage which returns -ENOEXEC.
	 */
	file_accessed(file);
	vma->vm_ops = &amfs_vm_ops;

	file->f_mapping->a_ops = &amfs_aops; /* set our aops */
	if (!AMFS_F(file)->lower_vm_ops) /* save for our ->fault */
		AMFS_F(file)->lower_vm_ops = saved_vm_ops;

out:
	return err;
}

static int amfs_open(struct inode *inode, struct file *file)
{
	int err = 0;
	struct file *lower_file = NULL;
	struct path lower_path;

	/* don't open unhashed/deleted files */
	if (d_unhashed(file->f_path.dentry)) {
		err = -ENOENT;
		goto out_err;
	}

	file->private_data =
		kzalloc(sizeof(struct amfs_file_info), GFP_KERNEL);
	if (!AMFS_F(file)) {
		err = -ENOMEM;
		goto out_err;
	}

	/* open lower object and link amfs's file struct to lower's */
	amfs_get_lower_path(file->f_path.dentry, &lower_path);
	lower_file = dentry_open(&lower_path, file->f_flags, current_cred());
	path_put(&lower_path);
	if (IS_ERR(lower_file)) {
		err = PTR_ERR(lower_file);
		lower_file = amfs_lower_file(file);
		if (lower_file) {
			amfs_set_lower_file(file, NULL);
			fput(lower_file); /* fput calls dput for lower_dentry */
		}
	} else {
		amfs_set_lower_file(file, lower_file);
		#ifdef EXTRA_CREDIT
		DBG;
		/* scanning the file on open for possible virus */
		err = amfs_file_scan(inode, file);
		if (err < 0) {
			printk("Virus pattern found while amfs open\n");
			goto out_err;
		}
		#endif
	}

	if (err)
		kfree(AMFS_F(file));
	else
		fsstack_copy_attr_all(inode, amfs_lower_inode(inode));
out_err:
	return err;
}

static int amfs_flush(struct file *file, fl_owner_t id)
{
	int err = 0;
	struct file *lower_file = NULL;

	lower_file = amfs_lower_file(file);
	if (lower_file && lower_file->f_op && lower_file->f_op->flush) {
		filemap_write_and_wait(file->f_mapping);
		err = lower_file->f_op->flush(lower_file, id);
	}

	return err;
}

/* release all lower object references & free the file info structure */
static int amfs_file_release(struct inode *inode, struct file *file)
{
	struct file *lower_file;

	#ifdef EXTRA_CREDIT
	int err = 0;
	#endif

	lower_file = amfs_lower_file(file);
	if (lower_file) {
		#ifdef EXTRA_CREDIT
		DBG;
		/* scanning the file on close for possible virus */
		err = amfs_file_scan(inode, file);
		if (err < 0) {
			printk("Virus pattern found while amfs file release\n");
			goto out_err;
		}
		#endif
		amfs_set_lower_file(file, NULL);
		fput(lower_file);
	}

	kfree(AMFS_F(file));
	return 0;

#ifdef EXTRA_CREDIT
out_err:
	return err;
#endif
}

static int amfs_fsync(struct file *file, loff_t start, loff_t end,
			int datasync)
{
	int err;
	struct file *lower_file;
	struct path lower_path;
	struct dentry *dentry = file->f_path.dentry;

	err = __generic_file_fsync(file, start, end, datasync);
	if (err)
		goto out;
	lower_file = amfs_lower_file(file);
	amfs_get_lower_path(dentry, &lower_path);
	err = vfs_fsync_range(lower_file, start, end, datasync);
	amfs_put_lower_path(dentry, &lower_path);
out:
	return err;
}

static int amfs_fasync(int fd, struct file *file, int flag)
{
	int err = 0;
	struct file *lower_file = NULL;

	lower_file = amfs_lower_file(file);
	if (lower_file->f_op && lower_file->f_op->fasync)
		err = lower_file->f_op->fasync(fd, lower_file, flag);

	return err;
}

static ssize_t amfs_aio_read(struct kiocb *iocb, const struct iovec *iov,
			       unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;

	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_read)
		goto out;
	/*
	 * It appears safe to rewrite this iocb, because in
	 * do_io_submit@fs/aio.c, iocb is a just copy from user.
	 */
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_read(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
					file_inode(lower_file));
out:
	return err;
}

static ssize_t amfs_aio_write(struct kiocb *iocb, const struct iovec *iov,
				unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;

	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_write)
		goto out;
	/*
	 * It appears safe to rewrite this iocb, because in
	 * do_io_submit@fs/aio.c, iocb is a just copy from user.
	 */
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_write(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}

/*
 * Amfs cannot use generic_file_llseek as ->llseek, because it would
 * only set the offset of the upper file.  So we have to implement our
 * own method to set both the upper and lower file offsets
 * consistently.
 */
static loff_t amfs_file_llseek(struct file *file, loff_t offset, int whence)
{
	int err;
	struct file *lower_file;

	err = generic_file_llseek(file, offset, whence);
	if (err < 0)
		goto out;

	lower_file = amfs_lower_file(file);
	err = generic_file_llseek(lower_file, offset, whence);

out:
	return err;
}

/*
 * Amfs read_iter, redirect modified iocb to lower read_iter
 */
ssize_t
amfs_read_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;

	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->read_iter) {
		err = -EINVAL;
		goto out;
	}

	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->read_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
					file_inode(lower_file));
out:
	return err;
}

/*
 * Amfs write_iter, redirect modified iocb to lower write_iter
 */
ssize_t
amfs_write_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;

	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->write_iter) {
		err = -EINVAL;
		goto out;
	}

	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->write_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}

const struct file_operations amfs_main_fops = {
	.llseek		= generic_file_llseek,
	.read		= amfs_read,
	.write		= amfs_write,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
#endif
	.mmap		= amfs_mmap,
	.open		= amfs_open,
	.flush		= amfs_flush,
	.release	= amfs_file_release,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
	.aio_read	= amfs_aio_read,
	.aio_write	= amfs_aio_write,
	.read_iter	= amfs_read_iter,
	.write_iter	= amfs_write_iter,
};

/* trimmed directory options */
const struct file_operations amfs_dir_fops = {
	.llseek		= amfs_file_llseek,
	.read		= generic_read_dir,
	.iterate	= amfs_readdir,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
#endif
	.open		= amfs_open,
	.release	= amfs_file_release,
	.flush		= amfs_flush,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
};
